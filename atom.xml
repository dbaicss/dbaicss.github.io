<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皮特撸斯</title>
  
  <subtitle>做正确的事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dbaicss.github.io/"/>
  <updated>2019-10-15T10:15:41.863Z</updated>
  <id>https://dbaicss.github.io/</id>
  
  <author>
    <name>dbaicss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scheduler源码分析</title>
    <link href="https://dbaicss.github.io/2019/10/15/Scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://dbaicss.github.io/2019/10/15/Scheduler源码分析/</id>
    <published>2019-10-15T06:02:38.000Z</published>
    <updated>2019-10-15T10:15:41.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scheduler作用"><a href="#Scheduler作用" class="headerlink" title="Scheduler作用"></a>Scheduler作用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scheduler一句话总结是主动请求api server,获取等待调度的pod信息列表,通过一系列的调度算法,帅选出满足需求的node, 将pod和node的绑定关系返回给api server,从而完成整个pod调度的过程</span><br></pre></td></tr></table></figure><h2 id="Scheduler代码结构"><a href="#Scheduler代码结构" class="headerlink" title="Scheduler代码结构"></a>Scheduler代码结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scheduler代码结构比较清晰,主要分为三个部分</span><br><span class="line">①. cmd/kube-scheduler/scheduler.go: 入口函数,完成一系列初始化动作</span><br><span class="line">②. pkg/scheduler/scheduler.go:  调度的具体逻辑</span><br><span class="line">③. pkg/scheduler/core/generic_scheduler.go: 具体的调度算法实现</span><br></pre></td></tr></table></figure><h2 id="接下来让我们逐个分析"><a href="#接下来让我们逐个分析" class="headerlink" title="接下来让我们逐个分析"></a>接下来让我们逐个分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cmd/kube-scheduler/scheduler.go, 入口函数,完成一系列初始化环境,读取配置,鉴权等操作,没什么好说的,直接跳过</span><br><span class="line">pkg/scheduler/scheduler.go, 调度的具体逻辑,从入口函数一路跟进去,NewSchedulerCommand()-&gt;runCommand()-&gt;Run()-&gt;sched.Run()-&gt;sched.scheduleOne,代码删除掉一些非线性逻辑之后如下:</span><br><span class="line">func (<span class="built_in">sched</span> *Scheduler) <span class="function"><span class="title">scheduleOne</span></span>() &#123;</span><br><span class="line">fwk := sched.Framework</span><br><span class="line">scheduleResult, err := sched.Algorithm.Schedule(state, pod)</span><br><span class="line">// Run <span class="string">"reserve"</span> plugins.</span><br><span class="line">// Run <span class="string">"permit"</span> plugins.</span><br><span class="line">// Run <span class="string">"prebind"</span> plugins.</span><br><span class="line">err := sched.bind(assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">主要的逻辑包括翻转插件,允许使用的插件,预绑定pod和node,以及绑定pod和node逻辑</span><br><span class="line">sched.Algorithm.Schedule跟进去可以看到定义了interface,包括6个方法</span><br><span class="line"><span class="built_in">type</span> ScheduleAlgorithm interface &#123;</span><br><span class="line">Schedule(*framework.CycleState, *v1.Pod) (scheduleResult ScheduleResult, err error)</span><br><span class="line">Preempt(*framework.CycleState, *v1.Pod, error) (selectedNode *v1.Node, preemptedPods []*v1.Pod, cleanupNominatedPods []*v1.Pod, err error)</span><br><span class="line">Predicates() map[string]predicates.FitPredicate</span><br><span class="line">Prioritizers() []priorities.PriorityConfig</span><br><span class="line">Extenders() []algorithm.SchedulerExtender</span><br><span class="line">&#125;</span><br><span class="line">关键的方法有三个,preempt抢占,predicates预选,prioritizers优选,另外三个方法不用太多关注</span><br><span class="line">sched.Algorithm.Schedule实际调用的是genericScheduler.Schedule()方法，在pkg/scheduler/core/generic_scheduler.go,总结起来就是尝试将指定的pod调度到给定的node列表中的一个，成功则返回node名字</span><br><span class="line">完整的业务流程图如下:</span><br></pre></td></tr></table></figure><p><img src="/images/scheduler-flow.png" alt="scheduler流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Scheduler作用&quot;&gt;&lt;a href=&quot;#Scheduler作用&quot; class=&quot;headerlink&quot; title=&quot;Scheduler作用&quot;&gt;&lt;/a&gt;Scheduler作用&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
